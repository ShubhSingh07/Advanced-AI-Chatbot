"""
SQL AI Agent - Compatible with OpenAI v1.x (Latest Version)
Install: pip install openai --upgrade
"""

import sqlite3
import json
import os
from typing import Dict, List, Tuple, Optional
from openai import OpenAI, RateLimitError, AuthenticationError, APIError


class SQLAgentV1:
    """SQL Agent using OpenAI v1.x API"""
    
    def __init__(self, db_path: str, api_key: Optional[str] = None):
        """
        Initialize SQL Agent
        
        Args:
            db_path: Path to SQLite database
            api_key: OpenAI API key (or set OPENAI_API_KEY env var)
        """
        self.db_path = db_path
        
        # Initialize OpenAI client (v1.x style)
        self.client = OpenAI(
            api_key=api_key or os.getenv("OPENAI_API_KEY")
        )
        
    def get_database_schema(self) -> str:
        """Get database schema information"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Get table info
            cursor.execute("PRAGMA table_info(api_data)")
            columns = cursor.fetchall()
            
            # Get sample data
            cursor.execute("SELECT * FROM api_data LIMIT 3")
            samples = cursor.fetchall()
            
            conn.close()
            
            schema = """
Database: Crop Production Database
Table: api_data

Columns:
"""
            for col in columns:
                schema += f"- {col[1]} ({col[2]})\n"
            
            schema += "\nSample Data:\n"
            schema += str(samples[:2])
            
            schema += """

Important Notes:
1. area_ and production_ are stored as TEXT but contain numeric values
2. Use CAST(column AS REAL) for numeric operations
3. Season values: 'Kharif', 'Rabi', 'Autumn', 'Whole Year'
4. production_ may contain 'NA' for missing data
5. Use LIKE '%keyword%' for partial text matching
6. Always add LIMIT clause to prevent huge result sets
"""
            return schema
            
        except sqlite3.Error as e:
            return f"Error reading schema: {str(e)}"
    
    def generate_sql_query(self, user_question: str, model: str = "gpt-3.5-turbo") -> Dict:
        """
        Convert natural language to SQL using GPT
        
        Args:
            user_question: Natural language question
            model: OpenAI model to use (gpt-3.5-turbo, gpt-4, gpt-4-turbo)
        
        Returns:
            Dict with 'query', 'explanation', or 'error'
        """
        
        schema = self.get_database_schema()
        
        system_prompt = f"""You are a SQL expert. Convert natural language questions into SQLite queries.

{schema}

Rules:
1. Only generate SELECT queries (no INSERT, UPDATE, DELETE)
2. Always use proper SQLite syntax
3. Handle NULL values and 'NA' strings appropriately
4. Use CAST for numeric operations on TEXT columns
5. Always add LIMIT clause (default 100 if not specified)
6. Return ONLY valid JSON with 'query' and 'explanation' keys

Response format (JSON only):
{{
    "query": "SELECT...",
    "explanation": "This query will..."
}}
"""
        
        try:
            # OpenAI v1.x syntax
            response = self.client.chat.completions.create(
                model=model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_question}
                ],
                temperature=0.1,
                max_tokens=500,
                response_format={"type": "json_object"}  # Force JSON response
            )
            
            # Extract response content
            result_text = response.choices[0].message.content
            
            # Parse JSON
            result = json.loads(result_text)
            return result
            
        except RateLimitError as e:
            return {
                "query": None,
                "explanation": None,
                "error": f"Rate Limit Error: {str(e)}. Check your OpenAI billing."
            }
        except AuthenticationError as e:
            return {
                "query": None,
                "explanation": None,
                "error": f"Authentication Error: {str(e)}. Check your API key."
            }
        except APIError as e:
            return {
                "query": None,
                "explanation": None,
                "error": f"API Error: {str(e)}"
            }
        except json.JSONDecodeError as e:
            return {
                "query": None,
                "explanation": None,
                "error": f"JSON Parse Error: {str(e)}"
            }
        except Exception as e:
            return {
                "query": None,
                "explanation": None,
                "error": f"Unexpected Error: {str(e)}"
            }
    
    def validate_sql_query(self, query: str) -> Tuple[bool, str]:
        """Validate SQL query for safety"""
        
        if not query or not isinstance(query, str):
            return False, "Invalid query"
        
        dangerous_keywords = [
            'DROP', 'DELETE', 'INSERT', 'UPDATE', 'ALTER', 
            'CREATE', 'TRUNCATE', 'EXEC', 'EXECUTE', 'PRAGMA'
        ]
        
        query_upper = query.upper()
        
        for keyword in dangerous_keywords:
            if keyword in query_upper:
                return False, f"Dangerous keyword detected: {keyword}"
        
        if not query_upper.strip().startswith('SELECT'):
            return False, "Only SELECT queries are allowed"
        
        # Check for multiple statements (SQL injection)
        if ';' in query[:-1]:  # Ignore trailing semicolon
            return False, "Multiple statements not allowed"
        
        return True, "Query is safe"
    
    def execute_query(self, query: str) -> Tuple[Optional[Dict], Optional[str]]:
        """Execute SQL query and return results"""
        
        # Validate first
        is_valid, message = self.validate_sql_query(query)
        if not is_valid:
            return None, f"Validation failed: {message}"
        
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute(query)
            results = cursor.fetchall()
            column_names = [description[0] for description in cursor.description]
            
            conn.close()
            
            return {
                'columns': column_names,
                'data': results,
                'row_count': len(results)
            }, None
            
        except sqlite3.Error as e:
            return None, f"SQL Error: {str(e)}"
    
    def format_results(self, results: Dict, max_rows: int = 50) -> str:
        """Format query results in a readable table"""
        
        if not results or not results.get('data'):
            return "\n‚ùå No results found.\n"
        
        columns = results['columns']
        data = results['data']
        row_count = results['row_count']
        
        # Calculate column widths
        col_widths = [len(str(col)) for col in columns]
        for row in data[:max_rows]:
            for i, val in enumerate(row):
                col_widths[i] = max(col_widths[i], len(str(val)[:30]))
        
        # Build output
        total_width = sum(col_widths) + len(columns) * 3
        output = "\n" + "=" * total_width + "\n"
        output += "üìä Query Results\n"
        output += "=" * total_width + "\n"
        
        # Header
        header = " | ".join([f"{col:<{col_widths[i]}}" for i, col in enumerate(columns)])
        output += header + "\n"
        output += "-" * total_width + "\n"
        
        # Rows
        display_rows = min(max_rows, len(data))
        for row in data[:display_rows]:
            row_str = " | ".join([
                f"{str(val)[:30]:<{col_widths[i]}}" 
                for i, val in enumerate(row)
            ])
            output += row_str + "\n"
        
        if row_count > display_rows:
            output += f"\n... ({row_count - display_rows} more rows)\n"
        
        output += "=" * total_width + "\n"
        output += f"‚úÖ Total rows: {row_count}\n"
        
        return output
    
    def generate_natural_response(self, user_question: str, results: Dict) -> str:
        """Generate natural language explanation of results"""
        
        if not results or results['row_count'] == 0:
            return "No data found for your query."
        
        # Create summary of results
        row_count = results['row_count']
        columns = results['columns']
        sample_data = results['data'][:3]
        
        summary = f"Found {row_count} results with columns: {', '.join(columns)}\n"
        summary += f"Sample data: {sample_data}"
        
        try:
            response = self.client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {
                        "role": "system", 
                        "content": "You are a helpful assistant. Explain query results in simple, natural language. Be concise."
                    },
                    {
                        "role": "user", 
                        "content": f"Question: {user_question}\n\nResults: {summary}\n\nExplain these results naturally in 2-3 sentences."
                    }
                ],
                temperature=0.7,
                max_tokens=150
            )
            
            return response.choices[0].message.content
            
        except Exception as e:
            return f"Results retrieved successfully. (Could not generate explanation: {str(e)})"
    
    def ask(self, user_question: str, model: str = "gpt-3.5-turbo", 
            generate_explanation: bool = True) -> Dict:
        """
        Main method: Process natural language question
        
        Args:
            user_question: Question in natural language
            model: OpenAI model (gpt-3.5-turbo, gpt-4, gpt-4-turbo)
            generate_explanation: Whether to generate natural language explanation
        
        Returns:
            Dict with success status, query, results, etc.
        """
        
        print(f"\n{'='*80}")
        print(f"ü§î Question: {user_question}")
        print(f"{'='*80}\n")
        
        # Step 1: Generate SQL
        print("üîÑ Generating SQL query...")
        sql_response = self.generate_sql_query(user_question, model=model)
        
        if 'error' in sql_response:
            print(f"‚ùå Error: {sql_response['error']}\n")
            return {
                'success': False,
                'error': sql_response['error']
            }
        
        query = sql_response.get('query')
        explanation = sql_response.get('explanation', '')
        
        if not query:
            print("‚ùå No query generated\n")
            return {
                'success': False,
                'error': 'No query generated'
            }
        
        print(f"‚úÖ Generated SQL:\n   {query}\n")
        print(f"üìù Explanation: {explanation}\n")
        
        # Step 2: Execute query
        print("‚öôÔ∏è  Executing query...")
        results, error = self.execute_query(query)
        
        if error:
            print(f"‚ùå Execution Error: {error}\n")
            return {
                'success': False,
                'query': query,
                'error': error
            }
        
        # Step 3: Format and display results
        formatted_results = self.format_results(results)
        print(formatted_results)
        
        # Step 4: Generate natural language response (optional)
        natural_response = None
        if generate_explanation and results['row_count'] > 0:
            print("üí¨ Generating natural language response...")
            natural_response = self.generate_natural_response(user_question, results)
            print(f"\nüí° Answer: {natural_response}\n")
        
        return {
            'success': True,
            'query': query,
            'explanation': explanation,
            'results': results,
            'formatted_results': formatted_results,
            'natural_response': natural_response
        }


# ============================================================================
# INTERACTIVE MODE
# ============================================================================

def interactive_mode(agent: SQLAgentV1):
    """Run agent in interactive chat mode"""
    
    print("\n" + "="*80)
    print("üåæ SQL AI AGENT - Interactive Mode (OpenAI v1.x)")
    print("="*80)
    print("\nüí° Ask questions about crop production data!")
    print("üìù Type 'help' for examples, 'quit' to exit\n")
    
    example_questions = [
        "show rice production in 2010",
        "which state produces most coconut",
        "total wheat area by state",
        "compare rice and wheat production",
        "top 5 crops by production",
        "average production of banana",
        "kharif season crops in 2015"
    ]
    
    while True:
        try:
            question = input("‚ùì Your question: ").strip()
            
            if not question:
                continue
            
            if question.lower() in ['quit', 'exit', 'q']:
                print("\nüëã Goodbye!\n")
                break
            
            if question.lower() in ['help', 'h', '?']:
                print("\nüìö Example questions:")
                for i, ex in enumerate(example_questions, 1):
                    print(f"  {i}. {ex}")
                print()
                continue
            
            # Process question
            result = agent.ask(question)
            
            if not result['success']:
                print(f"\n‚ùå Error: {result.get('error', 'Unknown error')}\n")
            
            print("\n" + "-"*80 + "\n")
            
        except KeyboardInterrupt:
            print("\n\nüëã Interrupted. Goodbye!\n")
            break
        except Exception as e:
            print(f"\n‚ùå Error: {str(e)}\n")


# ============================================================================
# MAIN - Example Usage
# ============================================================================

if __name__ == "__main__":
    import sys
    from dotenv import load_dotenv
    
    # Load environment variables
    load_dotenv()
    
    # Check for API key
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        print("‚ùå Error: OPENAI_API_KEY not found!")
        print("\nüîß Setup instructions:")
        print("1. Create a .env file in your project root")
        print("2. Add: OPENAI_API_KEY=sk-your-key-here")
        print("3. Get key from: https://platform.openai.com/api-keys")
        sys.exit(1)
    
    # Initialize agent
    try:
        agent = SQLAgentV1(
            db_path="/Users/shubh/Project/RAG-Projects/Advanced-AI-Chatbot/data/api_data.py/sql/crop_production.db",
            api_key=api_key
        )
        print("‚úÖ SQL Agent initialized successfully!\n")
    except Exception as e:
        print(f"‚ùå Error initializing agent: {str(e)}")
        sys.exit(1)
    
    # Check command line arguments
    if len(sys.argv) > 1:
        if sys.argv[1] == "--interactive" or sys.argv[1] == "-i":
            # Run in interactive mode
            interactive_mode(agent)
        else:
            # Run single question
            question = " ".join(sys.argv[1:])
            agent.ask(question)
    else:
        # Run example questions
        print("üß™ Running example questions...\n")
        
        test_questions = [
            "Show me rice production in 2010",
            "Which state produces the most coconut?",
            "What is the total area under wheat cultivation?",
            "Compare production of Rice and Wheat",
            "Show top 5 crops by production"
        ]
        
        for question in test_questions:
            result = agent.ask(question, generate_explanation=True)
            
            if not result['success']:
                print(f"‚ùå Failed: {result.get('error', 'Unknown error')}\n")
            
            print("\n" + "="*80 + "\n")
            input("Press Enter to continue...")